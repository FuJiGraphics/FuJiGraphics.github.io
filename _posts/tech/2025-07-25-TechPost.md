---
layout: post
pagination: 
  enabled: true
type: tech
date: 2025-07-25 16:24
category: Blog
title: "[Study] 자료구조 및 알고리즘 학습 정리"
subtitle: "필기노트"
writer: FuJiGraphics
post-header: false
image: thumnail.png
tags: [Study]
draft : false
---

{% capture img_url %}/assets/blog/tech/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

# [Study] 자료구조 및 알고리즘 학습 정리

자료구조와 알고리즘에 대해 학습했던 내용들을 하나하나 정리해가려고 합니다. 
포스팅은 학습 내용이 추가될 때마다 업데이트 될 예정입니다. 
포스팅 등록일 기준은 첫 포스팅 시점에 따릅니다. 



## 용어

**선형 구조 (Linear structure)**
→ `array, list, stack, queue` 등
→ **원소가 직선처럼 일렬로 나열됨**

**비선형 구조 (Nonlinear structure)**
→ `tree, graph`
→ 원소 간의 관계가 여러 갈래로 퍼짐
→ **비선형 구조는 `tree`와 `graph`가 유일함.**

**Underflow**
→ **데이터가 비어있는 상태**에서 **접근**할 경우 발생하는 **오류**

**Overflow**
→ **데이터가 꽉 차 있는 상태**에서 **추가**할 경우 발생하는 **오류**



## List

### 주요 개념

- **리스트**는 데이터가 연속적으로 저장되는 **순차자료구조**이다.
- **삽입** 또는 **삭제**가 되어도 연속된 메모리 공간에 빈 공간이 없이 저장된다.

> **리스트는 꼭 연속된 물리적인 공간에 저장되는 것은 아니다.**
>
> ① 김철수 : a 
>
> ② 박영희 : a+l
>
> ③ 홍길동 :a+2l
>
> ④ 이순신 : a+(i-1)





## 핵심 정리

| 자료구조                  | 메모리 배치                     | 크기 변경       | 특징                            |
| ------------------------- | ------------------------------- | --------------- | ------------------------------- |
| 정적 배열                 | 연속된 메모리                   | 불가능          | 크기 고정, 빠른 인덱스 접근     |
| 동적 배열 (`vector` 등)   | 연속된 메모리 (realloc 등 사용) | 가능하나 비싸다 | 자동 크기 확장, 재할당 발생     |
| 연결 리스트 (Linked List) | 비연속, 포인터로 연결           | 가능            | 메모리는 낭비되지만 유연성 높음 |



### 선형 리스트

- **순서(Ordered)** 리스트
- **"선형 리스트(linear list)"**라는 개념은 **논리적인 데이터 구조**의 관점에서 이야기하는 것이며,
   메모리 상의 물리적인 배치(연속/비연속)와는 별개 개념이다.
- **`정적 배열, 동적 배열, 연결 리스트` **등 모두 선형 리스트에 해당된다.
- 자료들 간에 순서를 가지는 리스트를 의미함
- 인덱스와 메모리 주소 `(a+0, a+1, a+2, a+n...)` 등으로 저장되는 (n+1)개의 **배열**이 대표적이다.
- 최악의 시간 복잡도는 **삽입**`O(N)`, **삭제** `O(N)`, **탐색** `O(1)`이다.
- 차원을 늘려서 아래와 같은 테이블 형태의 연속된 메모리 공간을 사용할 수 있다.

| 학번 | 이름   | 과목 |
| ---- | ------ | ---- |
| 01   | 김철수 | 수학 |
| 02   | 김민희 | 과학 |
| 03   | 홍길동 | 국어 |



#### 삭제 알고리즘

1. 삭제할 데이터를 비운다.
2. 빈 공간**뒤에 데이터들이 모두 앞으로 재배치**된다. (물리적 순서 = 논리적 순서 일치)[!TIP]

#### 삭제를 위한 이동 횟수

Q.  (n+1)개의 원소로 이루어진 선형리스트에서 k번 째 데이터를 삭제할 경우 이동 횟수를 구하시오

A. k번 째가 삭제될 경우 k+1이 앞으로 전진해야하므로, **`n - (k + 1) + 1`**번의 이동 횟수가 발생한다.



#### 삽입 알고리즘

1. 원소를 삽입할 빈 자리를 만든다. 즉 **한 자리씩 뒤로 이동**시킨다.
2. 데이터를 삽입한다.

#### 삽입을 위한 이동 횟수

Q. **(n+1)**개의 원소로 이루어진 선형리스트에서 k번 자리에 원소를 삽입하는 경우 이동 횟수를 구하시오.

A. k번 째부터 모든 원소의 자리를 이동시킬 경우 **`n - k + 1`**번의 이동 횟수가 발생한다.



#### 연결리스트

- 물리적 주소를 맞출 필요 없어서 이동에 대한 오버헤드가 적다.
- **크기 변경이 유연하고 메모리 사용이 효율적**이다.
- **노드 단위의 저장 방식**이며, **각 노드는 다음 노드에 대한 주소**를 가지고 있다.
- 첫번 째 노드를 가리키는 **Head**를 사용하여 처음부터 시작 가능

<center>
<img src="{{img_url}}/img_01.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">삽입 및 삭제 <i><b>(그림 A)</b></i></figcaption>
</center>



#### 원형 연결리스트

- 단순연결리스트와 비슷하지만 차이점은 원형으로 구성되어 **회전하면서 방문** 가능
- **끝 노드**가 **시작 노드**를 가리키는 방식으로 구성

<center>
<img src="{{img_url}}/img_02.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">원형연결리스트 <i><b>(그림 B)</b></i></figcaption>
</center>


## 스택 (Stack)

- 삽입 삭제 구조로 이루어진 **후입선출(LIFO)**의 자료구조이다.
- **배열** 또는 **연결** 구조 형태로 구현 가능하다.



### 스택의 연산

|     함수명     | 설명                                          |
| :------------: | --------------------------------------------- |
|   **Init()**   | 스택을 초기화한다.                            |
|  **push(e)**   | 요소 e를 스택의 맨 위에 추가한다.             |
|   **pop()**    | 스택의 맨 위에 있는 요소를 꺼내 반환한다.     |
| **is_empty()** | 스택이 비었을 경우 TRUE 아니면 FALSE          |
| **is_full()**  | 스택이 가득 차 있으면 TRUE, 아니면 FALSE      |
|   **peek()**   | 스택의 맨 위에 있는 항목을 삭제하지 않고 반환 |



### 응용 유형

- **괄호 검사**
  - **조건 1**: 왼쪽 괄호의 수와 오른쪽 괄호의 수가 같아야한다.
  - **조건 2**: 같은 종류이면 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 한다.
  - **조건 3**:서로 다른 괄호가 쌍을 이루면 안된다.
- **미로 찾기**
  - **조건 1**: 진행 가능한 방향에 대한 정보를 스택에 저장한다.
  - **조건 2**: 벽 또는 방문한 곳일 경우 스택의 다음 원소로 이동한다.



## 큐 (Queue)

- **선입선출(FIFO)** 구조



### 큐의 연산

|     함수명     | 설명                                        |
| :------------: | ------------------------------------------- |
|   **Init()**   | 큐을 초기화한다.                            |
| **enqueue(e)** | 요소 e를 큐의 맨 뒤에 추가한다.             |
| **dequeue()**  | 큐의 맨 앞 요소를 삭제하고 반환함           |
| **is_empty()** | 큐가 비었을 경우 TRUE 아니면 FALSE          |
| **is_full()**  | 큐가 가득 차 있으면 TRUE, 아니면 FALSE      |
|   **peek()**   | 큐의 맨 앞에 있는 항목을 삭제하지 않고 반환 |



### 큐의 종류

- **선형 큐**
  - 배열 구조로 **front**, **rear**가 있는 구조
- **원형 큐**
  - **공백 상태**: **front**와 **rear**의 위치가 같음
  - **꽉찬 상태**: `rear + 1 = front`인 상태
  - **front는 항상 원소보다 앞에 있어야 함** 
  - **rear**가 max size일 경우 `rear + 1 % MAX_SIZE` 여야 함



### 응용 유형

- **버퍼**
  - 데이터가 몰려들 경우, 이들을 잠시 보관하는 장소
- **다양한 알고리즘**
  - 레벨 순회, 너비우선탐색, 기수정렬

