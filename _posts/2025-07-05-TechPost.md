---
layout: post
pagination: 
  enabled: true
type: tech
date: 2025-07-05 12:00
category: Blog
title: "[VegaEngine3D] 프로젝트 시작 전 준비 작업"
subtitle: "2개월 간 개발을 위해 노션 페이지 제작 및 프로젝트 셋업"
writer: FuJiGraphics
post-header: false
image: 
tags: [Project]
draft : false
---

{% capture img_url %}/assets/blog/{{page.date | date: "%Y-%m-%d"}}-TechPost{% endcapture %}

# VegaEngine 3D

VegaEngine 2D의 코드를 기반으로 3D 게임 엔진을 제작하려고 한다. 

이 페이지에서는 게임 엔진에서 주요 핵심 시스템 위주로 정리해나갈 계획이다. 




# 프로젝트 세팅

## 노션 페이지 제작

2개월 간 게임 엔진 개발을 효율적으로 진행하기 위해 노션 페이지를 제작했다. 

나는 이번 개발에 `스프린트 방식`을 적용하고자 했다. 스프린트는 애자일 개발 방법론 중 하나인 스크럼에 포함된 개념으로, 1~4주 단위로 목표를 설정해 개발을 진행하는 방식이다.

비록 협업이 아닌 1인 개발이지만, 전체 개발 기간인 8주를 주차별 빌드 구간으로 나누고, 매주 목표를 설정해 단계적으로 개발을 진행해나가기로 했다.

아래는 간단히 만든 개발 일정을 관리하기 위한 노션 페이지이다.

<center>
<img src="{{img_url}}/img_01.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">작업 스프린트를 관리하기 위한 노션 <i><b>(그림 A)</b></i></figcaption>
</center>



## 베이스 코드 생성

기존에 만들었던 2D 게임 엔진의 베이스를 그대로 가져오려고 한다. 

일련의 로직 단위를 처리하는 `Layer Container`와 `팩토리 패턴`으로 의존성을 분리하고 따로 의존성 주입을 하는 방식으로 혹시라도 라이브러리를 변경해야하는 상황이 발생했을 때 대응할 수 있다.

<center>
<img src="{{img_url}}/img_02.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">기본적인 프로젝트 세팅 결과 <i><b>(그림 B)</b></i></figcaption>
</center>

기존 프로젝트에서 재활용된 코드는 다음과 같다.

- **Layer Container (Layer, LayerContainer, LayerPool)**
  -  로직 단위를 순서에 맞게 처리하는 컨테이너 
- **Pointer (Shared, Weak, Unique)**
  - 스마트 포인터를 랩퍼한 템플릿 라이브러리 
- **Window**
  - 윈도우 생성과 디스플레이, 입력 메세지 수신을 위한 **추상 클래스**
- **LogSystem (FZLog.hpp)**
  - 로그 시스템 및 디버깅 매크로를 포함한 자체 제작 라이브러리



## 팩토리 패턴 (의존성 분리)

**팩토리 패턴**이란 객체 생성을 서브 클래스에 위임해서 코드 로직과 생성자를 분리하는 패턴을 의미한다. 

윈도우를 생성하는 코드가 다음처럼 있다고 가정하자.

```c++
shared_ptr<Window> m_Window = WindowFactory::Create(winSpec); 
```

실제 `m_Window`는 추상 클래스의 인터페이스를 통해 관련 로직들을 실행한다.

```c++
void System::Init()
{
	// Init Window and run
	m_Window->Init();
}

void System::Release()
{
	m_Window->Release();
}

void System::Run()
{
	m_Window->Frame(m_IsRunning);
}
```

이 때, Window의 객체 생성은 Window가 하는 것이 아닌 WindowFactory가 담당한다.

```c++
enum class WindowAPI { Win32, SDL2 }

class WindowFactory
{
	Shared<Window> WindowFactory::Create(const WindowSpec& spec)
	{
		switch (spec.Api)
		{
			case WindowAPI::Win32:
				return CreateShared<WindowDX11>(spec);
            case WindowAPI::SDL2:
                return CreateShared<WindowSDL2>(spec);
		}
	}
}
```

이렇게 팩토리 패턴을 활용하면 기존 코드 구조의 변경 없이 새로운 로직을 포함 시킬 수 있기 때문에 다양한 라이브러리를 활용하거나 멀티 플랫폼 환경을 고려할 경우 유용한 패턴이다.



## 윈도우 생성

먼저 프로그램을 만들기 위해서 윈도우를 생성해야 한다. 현재 엔진은 **DirectX11** 기반 엔진이므로, Win32를 통해 윈도우 생성 코드를 작성하였다.

```c++
void WindowDX11::InitWindow()
{
	WNDCLASSEX wc = {};
	DEVMODE dmScreenSettings = {};
	int posX = 0, posY = 0;

	m_Hinstance = GetModuleHandle(nullptr);

	std::wstring widestr(m_Title.begin(), m_Title.end());
	const wchar_t* wTitle = widestr.c_str();

	// 윈도우 클래스 설정
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wc.lpfnWndProc = WndProc;
	wc.hInstance = m_Hinstance;
	wc.hIcon = LoadIcon(nullptr, IDI_WINLOGO);
	wc.hIconSm = wc.hIcon;
	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
	wc.lpszClassName = wTitle;

	RegisterClassEx(&wc);

	DWORD style = 0;
	DWORD exStyle = WS_EX_APPWINDOW;

	if (m_IsFullscreen)
	{
		style = WS_POPUP;

		m_Width = GetSystemMetrics(SM_CXSCREEN);
		m_Height = GetSystemMetrics(SM_CYSCREEN);

		dmScreenSettings.dmSize = sizeof(dmScreenSettings);
		dmScreenSettings.dmPelsWidth = m_Width;
		dmScreenSettings.dmPelsHeight = m_Height;
		dmScreenSettings.dmBitsPerPel = 32;
		dmScreenSettings.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;

		ChangeDisplaySettings(&dmScreenSettings, CDS_FULLSCREEN);

		posX = posY = 0;
	}
	else
	{
		style = WS_OVERLAPPEDWINDOW;

		posX = (GetSystemMetrics(SM_CXSCREEN) - m_Width) / 2;
		posY = (GetSystemMetrics(SM_CYSCREEN) - m_Height) / 2;
	}

	m_Hwnd = CreateWindowEx(
		exStyle,
		wTitle,
		wTitle,
		style,
		posX,
		posY,
		m_Width,
		m_Height,
		nullptr,
		nullptr,
		m_Hinstance,
		nullptr
	);

	ShowWindow(m_Hwnd, SW_SHOW);
	SetForegroundWindow(m_Hwnd);
	SetFocus(m_Hwnd);
	ShowCursor(false);
}
```

<center>
<img src="{{img_url}}/img_0.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">윈도우 생성 결과<i><b>(그림 C)</b></i></figcaption>
</center>
**다양한 플랫폼(OpenGL, Vulkan 등)**에 대응하거나 게임 패드와 같은 장치와의 호환성을 고려해야 할 수도 있기 때문에, 이러한 부분을 직접 구현하는 번거로움이 생길 수 있다. 이는 게임 엔진 개발보다 윈도우 프로그래밍에 더 많은 비중이 쏠릴 우려가 있어, 나는 2개월이라는 한정된 개발 기간 동안 엔진 개발에 집중하기 위해 [SDL2](https://www.libsdl.org/)를 도입하기로 결정했다.
 다행히 `Window` 클래스는 팩토리 패턴으로 구성되어 있어, 새로운 기능을 추가하는 작업도 비교적 수월하게 진행할 수 있었다.



```c++
#pragma once
#include "Defines.h"

// SDL
struct SDL_Window;
struct SDL_Surface;

namespace vega {

	class IWindow;
	struct WindowSpec;

	class WindowSDL2 : public IWindow
	{
	public:
		WindowSDL2(const WindowSpec& spec);
		virtual ~WindowSDL2();

		void Init() final;
		void Release() final;
		void PollEvent() final;
		void Frame() final;

		inline unsigned int GetWidth() const final { return m_Width; }
		inline unsigned int GetHeight() const final { return m_Height; }
		inline std::string GetTitle() const final { return m_Title; }

		void SetEventCallback(const EventCallbackFn& callback) final;

	private:
		unsigned int m_Width;
		unsigned int m_Height;
		std::string m_Title;
		bool m_IsFullscreen;
		bool m_IsReleased;

		EventCallbackFn	m_EventCallbackFunc;
		SDL_Window* m_pWindow;
		SDL_Surface* m_pSurface;
	};

} // namespace vega

```

기존 `IWindow`를 기반으로 SDL2 윈도우 생성 코드를 작성하였다. 





# Input System

사용자로부터 입력을 받아 엔진에서 처리하기 위해 **Input System**을 구현하였다.

**Input System**은 **Event**와 **Input Polling Manager** 두 개의 구성으로 되어있다.



## Event System

**이벤트**는 프로그램 기준에서 윈도우가 꺼지거나 키 입력이 들어오는 등 외부에서 발생하는 작용을 의미한다.

**Event System**은 이러한 이벤트를 받아 레이어 단위로 전달하며 레이어들에게 이벤트에 대한 정보를 알리고, 상위 레이어에서 이벤트가 처리되었을 경우, 해당 이벤트가 하위 레이어로 전달되지 않도록 막는 역할을 한다.

다음은 **Hazel Engine**에서 사용중인 **Event System**을 살짝 커스터마이징한 **Event System**이다.



### Event Class

####  EventType 열거형 (enum class)

```c++
enum class EventType {
    None = 0,
    WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,
    AppTick, AppUpdate, AppRender,
    KeyPressed, KeyReleased, KeyTyped,
    MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled
};
```

- **이벤트의 구체적인 종류**를 정의한다.
- 각 이벤트는 하나의 고유 타입을 가지며, 이를 통해 특정 이벤트가 발생했는지 구분할 수 있다.
- 예시:
  - `WindowClose`: 창이 닫힐 때 발생
  - `KeyPressed`: 키보드 키가 눌릴 때 발생
  - `MouseMoved`: 마우스가 이동할 때 발생



####  EventCategory 열거형 (비트플래그)

```c++
enum EventCategory {
    None = 0,
    EventCategoryApplication = BIT(0),
    EventCategoryInput       = BIT(1),
    EventCategoryKeyboard    = BIT(2),
    EventCategoryMouse       = BIT(3),
    EventCategoryMouseButton = BIT(4)
};
```

- **이벤트를 그룹화**하기 위한 **카테고리 플래그**이다.
- `BIT(x)`는 `#define BIT(x) (1 << x)` 형태로 정의되어 있다.
- 여러 카테고리를 동시에 가질 수 있게 비트 마스크 방식으로 구성되어 있다.
  - 예: `Keyboard`는 `Input`의 하위 개념이므로, 둘 다 체크 가능



####  이벤트 매크로 정의

```c++
#define EVENT_CLASS_TYPE(type) 													\
    static EventType GetStaticType() { return EventType::##type; } 				\
    virtual EventType GetEventType() const override { return GetStaticType(); } \
    virtual const char* GetName() const override { return #type; }

#define EVENT_CLASS_CATEGORY(category) 											\
    virtual int GetCategoryFlags() const override { return category; }
```

- 이벤트 클래스에서 **유형(type)** 및 **카테고리(category)** 정보를 간편하게 정의할 수 있게 해줍니다.
- 예를 들어, `WindowCloseEvent` 클래스에서 `EVENT_CLASS_TYPE(WindowClose)`를 쓰면:
  - `GetStaticType()` → `EventType::WindowClose`
  - `GetName()` → `"WindowClose"`



#### Event 추상 클래스 (Base Class)

```c++
class Event {
	friend class EventDispatcher;

public:
	virtual EventType GetEventType() const = 0;
	virtual const char* GetName() const = 0;
	virtual int GetCategoryFlags() const = 0;
	virtual std::string ToString() const { return GetName(); }

	inline bool IsInCategory(EventCategory category) {
		return GetCategoryFlags() & category;
	}

public:
	bool handled = false;
};
```

- **모든 이벤트의 공통 기반 클래스**이다
- 순수 가상 함수(`= 0`)를 통해 자식 클래스가 반드시 이벤트 타입/이름/카테고리를 정의하게 강제한다.
- `handled` 플래그:
  - 이벤트가 처리되었는지 여부를 나타낸다.
  - 상위 레이어에서 이벤트를 처리했을 경우 `true`로 설정하여 하위 레이어로 전달되지 않게 함
- `IsInCategory()`:
  - 이 이벤트가 특정 카테고리에 속해 있는지 비트 마스크 연산으로 판단

**예1) WindowResizeEvent 클래스**

```c++
class WindowResizeEvent : public Event {
public:
	WindowResizeEvent(unsigned int width, unsigned int height)
		: m_Width(width), m_Height(height) {}

	inline unsigned int GetWidth() const { return m_Width; }
	inline unsigned int GetHeight() const { return m_Height; }

	std::string ToString() const override {
		std::stringstream ss;
		ss << "WindowResizeEvent: " << m_Width << ", " << m_Height;
		return ss.str();
	}

	EVENT_CLASS_TYPE(WindowResize)
	EVENT_CLASS_CATEGORY(EventCategoryApplication)

private:
	unsigned int m_Width, m_Height;
};
```

- 창의 크기가 변경될 때 발생하는 이벤트
- `ToString()`을 오버라이드하여, 로그 등에서 출력할 수 있는 문자열 정보 생성
- `GetWidth()`, `GetHeight()`로 새 크기를 조회 가능
- 타입: `WindowResize`, 카테고리: `Application`



**예2) WindowCloseEvent 클래스**

```c++
class WindowCloseEvent : public Event {
public:
	WindowCloseEvent() {}

	EVENT_CLASS_TYPE(WindowClose)
	EVENT_CLASS_CATEGORY(EventCategoryApplication)
};
```

- 창을 닫을 때 발생하는 단순한 이벤트
- 별도의 추가 정보가 없기 때문에 `ToString()`은 따로 오버라이드하지 않음



### EventDispatcher Class

```c++
class EventDispatcher
	{
		template<typename T>
		using EventFn = std::function<bool(T&)>;
	public:
		EventDispatcher(Event& event)
			: m_Event(event)
		{
			// Empty
		}

		template<typename T>
		bool Dispatch(EventFn<T> func)
		{
			if (m_Event.GetEventType() == T::GetStaticType())
			{
				m_Event.handled = func(*(T*)&m_Event);
				return true;
			}
			return false;
		}
	private:
		Event& m_Event;
	};

```

`EventDispatcher`는 이벤트가 발생했을 때 콜백 함수에 이벤트 정보를 전달한다.

```c++
	EventDispatcher dispatcher(e);
	dispatcher.Dispatch<WindowCloseEvent>(BIND_EVENT_FUNC(System::OnWindowClose));
```

위 코드에서 `Dispatch` 함수는 `BIND_EVENT_FUNC`를 통해 생성된 함수 객체를 전달받아, 이벤트 타입이 `WindowCloseEvent`일 경우 해당 콜백을 실행한다. 이 예시는 윈도우가 종료되었을 때 `System::OnWindowClose` 멤버 함수가 호출되도록 이벤트를 등록한 것이다.

`BIND_EVENT_FUNC`는 `std::bind`를 간편하게 사용할 수 있도록 정의한 매크로로, 멤버 함수를 함수 객체로 감싸기 위해 사용된다.



### Evene System Flow

```php
[윈도우가 닫힘 발생]
       ↓
WindowCloseEvent 생성
       ↓
EventDispatcher가 해당 이벤트를 받아 적절한 핸들러에 전달
       ↓
핸들러 함수 실행 (예: System::OnWindowClose)
       ↓
이벤트 처리 완료되면 handled = true
```





# Timeline

이 항목은 개발한 날짜를 기준으로 변경사항 대해서 자유롭게 작성하려고 한다.



## 2025/08/05

`SDL2`에 맞는 `Input Polling System`을 구현하였다.

```c++
void WindowSDL2::PollEvent()
	{
		if (m_EventCallbackFunc == nullptr)
			return;

		SDL_Event event;
		while (SDL_PollEvent(&event))
		{
			switch (event.type)
			{
				case SDL_QUIT: {
					WindowCloseEvent e;
					m_EventCallbackFunc(e);
				} break;
				case SDL_KEYDOWN: {
					std::cout << event.key.keysym.sym << std::endl;
					KeyPressedEvent e(TypeConverter::ToVegaKeyType(event.key.keysym.sym));
					m_EventCallbackFunc(e);
				} break;
				case SDL_KEYUP: {
					KeyReleasedEvent e(TypeConverter::ToVegaKeyType(event.key.keysym.sym));
					m_EventCallbackFunc(e);
				} break;
				case SDL_MOUSEBUTTONDOWN: {
					MouseButtonPressedEvent e(TypeConverter::ToVegaMouseButtonType(event.button.type));
					m_EventCallbackFunc(e);
				} break;
				case SDL_MOUSEBUTTONUP: {
					MouseButtonReleasedEvent e(TypeConverter::ToVegaMouseButtonType(event.button.type));
					m_EventCallbackFunc(e);
				} break;
				case SDL_MOUSEMOTION: {
					MouseMovedEvent e(
						static_cast<int>(event.button.x), 
						static_cast<int>(event.button.y)
					);
					m_EventCallbackFunc(e);
				}
			}
		}

	}
```

<center>
<img src="{{img_url}}/img_04.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">Input Polling<i><b>(그림 D)</b></i></figcaption>
</center>





### Repeat 기능 추가

Polling에 문제가 없는 것 같으니, 버튼 입력을 누르고 있을 때 Repeat 횟수를 측정하는 코드를 추가로 작성하였다.

		bool m_RepeatOn;
		int m_RepeatCount;

`WindowSDL2` 클래스 멤버로 두개의 멤버 변수를 추가한다.

				case SDL_KEYDOWN: {
					if (m_RepeatOn == false)
					{
						m_RepeatOn = true;
						m_RepeatCount = 0;
					}
					else
						m_RepeatCount++;
					KeyPressedEvent e(TypeConverter::ToVegaKeyType(event.key.keysym.sym), m_RepeatCount);
					m_EventCallbackFunc(e);
				} break;
				case SDL_KEYUP: {
					m_RepeatOn = false;
					m_RepeatCount = 0;
					KeyReleasedEvent e(TypeConverter::ToVegaKeyType(event.key.keysym.sym));
					m_EventCallbackFunc(e);
				} break;

이후 폴링 구간에서 클릭 시 `RepeatCount`를 측정해주는 코드를 넣는다. 

<center>
<img src="{{img_url}}/img_05.png" style="max-width:527px; width:100%;">
<figcaption style="margin-top:-30px;">Input Polling<i><b>(그림 5)</b></i></figcaption>
</center>

문제없이 잘 되는 것 같다.



### 최적화 (SDL 이벤트 처리)

SDL을 사용한 이벤트 처리에서 가장 일반적인 방법은 `switch`문을 통해 각 이벤트 타입을 분기 처리하는 방식이다. 하지만 이벤트가 많아질수록 `switch`문의 조건 분기가 길어지고, 각 이벤트에 대한 처리 흐름도 복잡해진다는 단점이 있다.

이를 해결하기 위해 이벤트 타입별로 대응되는 로직을 미리 등록해두고, 실행 시 직접 찾아 호출하는 구조로 리팩토링하였다. `unordered_map`과 `std::function`을 활용하여 키 기반 함수 디스패치 방식으로 이벤트를 처리하도록 변경한 것이다.

> [!TIP]
>
> ### **실제로는 O(1)일 수 있음** — *컴파일러 최적화 관점*
>
> 현대 C++ 컴파일러(예: MSVC, Clang, GCC)는 `switch`문을 다음과 같이 최적화할 수 있다:
>
> - **jump table (분기 테이블)** → key값을 인덱스로 직접 함수 포인터 배열처럼 접근
>    ⟶ 시간 복잡도 O(1)
> - **binary search tree 분기** → O(log N)
> - **fallback to if-else chain** → O(N)
>
> 즉, 컴파일러는 **case 값이 조밀하게 연속된 정수**일 경우 **O(1) jump table 최적화**를 자동으로 수행한다.

그러나 **현재 SDL 이벤트 타입 및 키코드는 조밀하게 연속된 정수가 아니며**, 일부 값은 10억 단위의 비트마스크를 포함하고 있어 jump table 최적화가 불가능하다.
 따라서 `unordered_map` 기반의 해시 디스패치 구조를 도입하여, `switch`문보다 평균적으로 더 나은 성능과 유지보수 편의성을 확보하였다.



#### 기존 방식: switch문 기반 이벤트 분기

기존 방식은 다음과 같은 코드 구조로 되어 있었다:

```c++
SDL_Event event;
while (SDL_PollEvent(&event)) {
	switch (event.type) {
		case SDL_QUIT: {
			WindowCloseEvent e;
			m_EventCallbackFunc(e);
			break;
		}
		case SDL_KEYDOWN: {
			KeyPressedEvent e(TypeConverter::ToVegaKeyType(event.key.keysym.sym), 0);
			m_EventCallbackFunc(e);
			break;
		}
		// 기타 이벤트...
	}
}
```

이 구조는 명확하지만, 이벤트 타입이 많아질수록 `case` 문이 과도하게 늘어나고, 한눈에 전체 흐름을 파악하기 어려워진다는 단점이 있다.



#### 개선 방식: 이벤트 디스패처 맵 도입

개선된 구조에서는 `std::unordered_map`을 사용해 이벤트 타입(`event.type`)을 키로 사용하고, 해당 이벤트를 처리할 람다 함수를 값으로 등록한다. 이를 통해 불필요한 조건 분기를 제거하고, 직접 해당 이벤트 처리기를 호출할 수 있도록 하였다.

```c++
std::unordered_map<int, std::function<void(SDL_Event&)>> m_EventHandlerMap;
```

`InitEventHandler()` 함수에서 다음과 같이 각 이벤트에 대한 처리 로직을 람다 형태로 미리 등록해둔다:

```c++
m_EventHandlerMap[SDL_QUIT] = [this](SDL_Event& e) {
	WindowCloseEvent ev;
	m_EventCallbackFunc(ev);
};

m_EventHandlerMap[SDL_KEYDOWN] = [this](SDL_Event& e) {
	KeyPressedEvent ev(TypeConverter::ToVegaKeyType(e.key.keysym.sym), m_RepeatCount++);
	m_EventCallbackFunc(ev);
};
```

이제 이벤트 폴링 시점에서는 다음과 같이 매우 간결하게 이벤트를 처리할 수 있다:

```c++
SDL_Event event;
while (SDL_PollEvent(&event)) {
	if (m_EventHandlerMap.contains(event.type)) {
		m_EventHandlerMap[event.type](event);
	}
}
```

맵을 통한 디스패치는 O(1) 해시 탐색으로 처리되기 때문에 성능적인 이점도 있으며, 특히 이벤트가 자주 발생하는 환경에서는 조건 분기문보다 오버헤드를 줄일 수 있다.



#### 구조 확장성

이벤트가 추가될 때마다 `switch`문을 수정할 필요 없이, `InitEventHandler()` 함수에 한 줄만 추가하면 된다:

```c++
m_EventHandlerMap[SDL_MOUSEBUTTONDOWN] = [this](SDL_Event& e) {
	MouseButtonPressedEvent ev(TypeConverter::ToVegaMouseButtonType(e.button.button));
	m_EventCallbackFunc(ev);
};
```

이는 구조적으로 **확장성과 유지보수성**이 매우 뛰어난 방식이다.



#### 결과

`switch`문을 사용한 전통적인 이벤트 처리 방식은 간단하고 직관적이지만, 이벤트가 많아질수록 구조가 복잡해지고 유지보수가 어려워지는 단점이 있다.
 이를 해결하기 위해 이벤트 타입을 키로, 처리 로직을 람다 함수로 맵핑한 `unordered_map` 기반 이벤트 디스패처 구조를 도입함으로써, 분기 오버헤드를 줄이고 코드의 가독성과 유연성을 모두 확보할 수 있었다.

이러한 구조는 SDL뿐 아니라 ImGui, 엔진 구조, 유니티의 메시지 시스템 등에서도 적용 가능한 패턴으로, 이벤트 처리 성능과 관리 효율성을 동시에 향상시키는 데 효과적인 방법이다.
